"""
Storage Repository

数据访问层，处理文件存储相关的数据库操作
Migrated to use PostgresClient with gRPC
"""

import logging
from typing import List, Optional, Dict, Any
from datetime import datetime, timedelta
import uuid
import json

# Database client setup
import sys
import os
sys.path.append(os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))

from isa_common.postgres_client import PostgresClient
from google.protobuf.json_format import MessageToDict
from .models import (
    StoredFile, FileShare, StorageQuota,
    FileStatus, StorageProvider, FileAccessLevel,
    PhotoVersion, PhotoVersionType
)

logger = logging.getLogger(__name__)


class StorageRepository:
    """存储数据访问层"""

    def __init__(self):
        """初始化存储仓库"""
        self.db = PostgresClient(
            host='isa-postgres-grpc',
            port=50061,
            user_id='storage_service'
        )
        # 表名定义 - 使用dev schema
        self.schema = "dev"
        self.files_table = "storage_files"
        self.shares_table = "file_shares"
        self.quotas_table = "storage_quotas"

    def _convert_proto_jsonb(self, jsonb_raw):
        """Convert proto JSONB to Python dict"""
        if hasattr(jsonb_raw, 'fields'):
            return MessageToDict(jsonb_raw)
        return jsonb_raw if jsonb_raw else {}
    
    # ==================== 文件操作 ====================
    
    async def create_file_record(self, file_data: StoredFile) -> StoredFile:
        """创建文件记录"""
        try:
            data = {
                "file_id": file_data.file_id,
                "user_id": file_data.user_id,
                "organization_id": file_data.organization_id,
                "file_name": file_data.file_name,
                "file_path": file_data.file_path,
                "file_size": file_data.file_size,
                "content_type": file_data.content_type,
                "file_extension": file_data.file_extension,
                "storage_provider": file_data.storage_provider.value,
                "bucket_name": file_data.bucket_name,
                "object_name": file_data.object_name,
                "status": file_data.status.value,
                "access_level": file_data.access_level.value,
                "checksum": file_data.checksum,
                "etag": file_data.etag,
                "version_id": file_data.version_id,
                "metadata": file_data.metadata,
                "tags": file_data.tags,
                "download_url": file_data.download_url,
                "download_url_expires_at": file_data.download_url_expires_at.isoformat() if file_data.download_url_expires_at else None,
                "uploaded_at": file_data.uploaded_at.isoformat() if file_data.uploaded_at else datetime.utcnow().isoformat(),
                "updated_at": datetime.utcnow().isoformat()
            }
            
            result = self.supabase.table(self.files_table).insert(data).execute()
            
            if result.data:
                return StoredFile.model_validate(result.data[0])
            return None
                
        except Exception as e:
            logger.error(f"Error creating file record: {e}")
            raise
    
    async def get_file_by_id(self, file_id: str, user_id: Optional[str] = None) -> Optional[StoredFile]:
        """根据文件ID获取文件记录"""
        try:
            query = self.supabase.table(self.files_table).select("*").eq("file_id", file_id)

            if user_id:
                query = query.eq("user_id", user_id)

            # 排除已删除的文件
            query = query.neq("status", FileStatus.DELETED.value)

            result = query.execute()

            if result.data and len(result.data) > 0:
                return StoredFile.model_validate(result.data[0])
            return None

        except Exception as e:
            logger.error(f"Error getting file: {e}")
            return None
    
    async def list_user_files(
        self,
        user_id: str,
        organization_id: Optional[str] = None,
        status: Optional[FileStatus] = None,
        prefix: Optional[str] = None,
        limit: int = 100,
        offset: int = 0
    ) -> List[StoredFile]:
        """列出用户文件"""
        try:
            query = self.supabase.table(self.files_table).select("*").eq("user_id", user_id)
            
            if organization_id:
                query = query.eq("organization_id", organization_id)
            
            if status:
                query = query.eq("status", status.value)
            else:
                # 默认排除已删除的文件
                query = query.neq("status", FileStatus.DELETED.value)
            
            if prefix:
                query = query.ilike("file_name", f"{prefix}%")
            
            # 排序和分页
            query = query.order("uploaded_at", desc=True).range(offset, offset + limit - 1)
            
            result = query.execute()
            
            if result.data:
                return [StoredFile.model_validate(row) for row in result.data]
            return []
                
        except Exception as e:
            logger.error(f"Error listing files: {e}")
            return []
    
    async def update_file_status(
        self,
        file_id: str,
        status: FileStatus,
        error_message: Optional[str] = None
    ) -> bool:
        """更新文件状态"""
        try:
            update_data = {
                "status": status.value,
                "updated_at": datetime.utcnow().isoformat()
            }
            
            if status == FileStatus.DELETED:
                update_data["deleted_at"] = datetime.utcnow().isoformat()
            
            result = self.supabase.table(self.files_table).update(update_data).eq("file_id", file_id).execute()
            
            return len(result.data) > 0 if result.data else False
                
        except Exception as e:
            logger.error(f"Error updating file status: {e}")
            return False
    
    async def delete_file(self, file_id: str, user_id: str) -> bool:
        """删除文件（软删除）"""
        try:
            update_data = {
                "status": FileStatus.DELETED.value,
                "deleted_at": datetime.utcnow().isoformat(),
                "updated_at": datetime.utcnow().isoformat()
            }
            
            result = self.supabase.table(self.files_table).update(update_data).eq("file_id", file_id).eq("user_id", user_id).execute()
            
            return len(result.data) > 0 if result.data else False
                
        except Exception as e:
            logger.error(f"Error deleting file: {e}")
            return False
    
    # ==================== 文件分享操作 ====================
    
    async def create_file_share(self, share_data: FileShare) -> FileShare:
        """创建文件分享"""
        try:
            share_id = f"share_{uuid.uuid4().hex[:12]}"
            
            data = {
                "share_id": share_id,
                "file_id": share_data.file_id,
                "shared_by": share_data.shared_by,
                "shared_with": share_data.shared_with,
                "shared_with_email": share_data.shared_with_email,
                "access_token": share_data.access_token,
                "password": share_data.password,
                "permissions": share_data.permissions,
                "max_downloads": share_data.max_downloads,
                "download_count": 0,
                "expires_at": share_data.expires_at.isoformat() if share_data.expires_at else None,
                "is_active": True,
                "created_at": datetime.utcnow().isoformat()
            }
            
            result = self.supabase.table(self.shares_table).insert(data).execute()
            
            if result.data:
                share_data.share_id = share_id
                return FileShare.model_validate(result.data[0])
            return None
                
        except Exception as e:
            logger.error(f"Error creating file share: {e}")
            raise
    
    async def get_file_share(
        self,
        share_id: str,
        access_token: Optional[str] = None
    ) -> Optional[FileShare]:
        """获取文件分享"""
        try:
            query = self.supabase.table(self.shares_table).select("*").eq("share_id", share_id).eq("is_active", True)
            
            # 检查是否过期
            query = query.or_(f"expires_at.is.null,expires_at.gt.{datetime.utcnow().isoformat()}")
            
            if access_token:
                query = query.eq("access_token", access_token)
            
            result = query.single().execute()
            
            if result.data:
                return FileShare.model_validate(result.data)
            return None
                
        except Exception as e:
            if "No rows found" in str(e):
                return None
            logger.error(f"Error getting file share: {e}")
            raise
    
    async def increment_share_download(self, share_id: str) -> bool:
        """增加分享下载次数"""
        try:
            # 先获取当前下载次数
            result = self.supabase.table(self.shares_table).select("download_count").eq("share_id", share_id).single().execute()
            
            if result.data:
                current_count = result.data.get("download_count", 0)
                
                update_data = {
                    "download_count": current_count + 1,
                    "accessed_at": datetime.utcnow().isoformat()
                }
                
                result = self.supabase.table(self.shares_table).update(update_data).eq("share_id", share_id).eq("is_active", True).execute()
                
                return len(result.data) > 0 if result.data else False
            return False
                
        except Exception as e:
            logger.error(f"Error incrementing share download: {e}")
            return False
    
    # ==================== 配额操作 ====================
    
    async def get_storage_quota(
        self,
        user_id: Optional[str] = None,
        organization_id: Optional[str] = None
    ) -> Optional[StorageQuota]:
        """获取存储配额"""
        try:
            query = self.supabase.table(self.quotas_table).select("*").eq("is_active", True)
            
            if user_id:
                query = query.eq("user_id", user_id)
            
            if organization_id:
                query = query.eq("organization_id", organization_id)
            
            if not user_id and not organization_id:
                return None
            
            result = query.single().execute()
            
            if result.data:
                return StorageQuota.model_validate(result.data)
            return None
                
        except Exception as e:
            if "No rows found" in str(e):
                return None
            logger.error(f"Error getting storage quota: {e}")
            return None
    
    async def update_storage_usage(
        self,
        user_id: Optional[str] = None,
        organization_id: Optional[str] = None,
        bytes_delta: int = 0,
        file_count_delta: int = 0
    ) -> bool:
        """更新存储使用量"""
        try:
            # 先获取当前使用量
            query = self.supabase.table(self.quotas_table).select("used_bytes, file_count")
            
            if user_id:
                query = query.eq("user_id", user_id)
            
            if organization_id:
                query = query.eq("organization_id", organization_id)
            
            if not user_id and not organization_id:
                return False
            
            result = query.single().execute()
            
            if result.data:
                current_bytes = result.data.get("used_bytes", 0)
                current_count = result.data.get("file_count", 0)
                
                update_data = {
                    "used_bytes": max(0, current_bytes + bytes_delta),  # 确保不会变成负数
                    "file_count": max(0, current_count + file_count_delta),
                    "updated_at": datetime.utcnow().isoformat()
                }
                
                query = self.supabase.table(self.quotas_table).update(update_data)
                
                if user_id:
                    query = query.eq("user_id", user_id)
                if organization_id:
                    query = query.eq("organization_id", organization_id)
                
                result = query.execute()
                return len(result.data) > 0 if result.data else False
            else:
                # 如果没有配额记录，创建一个默认的
                if user_id:
                    default_quota = {
                        "user_id": user_id,
                        "organization_id": organization_id,
                        "total_quota_bytes": 10 * 1024 * 1024 * 1024,  # 10GB
                        "used_bytes": max(0, bytes_delta),
                        "file_count": max(0, file_count_delta),
                        "is_active": True,
                        "updated_at": datetime.utcnow().isoformat()
                    }
                    result = self.supabase.table(self.quotas_table).insert(default_quota).execute()
                    return len(result.data) > 0 if result.data else False
            
            return False
                
        except Exception as e:
            logger.error(f"Error updating storage usage: {e}")
            return False
    
    async def get_storage_stats(
        self,
        user_id: Optional[str] = None,
        organization_id: Optional[str] = None
    ) -> Dict[str, Any]:
        """获取存储统计信息"""
        try:
            # 获取文件列表
            query = self.supabase.table(self.files_table).select("file_size, content_type, status")
            
            if user_id:
                query = query.eq("user_id", user_id)
            
            if organization_id:
                query = query.eq("organization_id", organization_id)
            
            # 排除已删除的文件
            query = query.neq("status", FileStatus.DELETED.value)
            
            result = query.execute()
            
            # 统计信息
            stats = {
                "file_count": 0,
                "total_size": 0,
                "by_type": {},
                "by_status": {}
            }
            
            if result.data:
                stats["file_count"] = len(result.data)
                
                for file in result.data:
                    # 总大小
                    file_size = file.get("file_size", 0)
                    stats["total_size"] += file_size
                    
                    # 按类型统计
                    content_type = file.get("content_type", "unknown")
                    if content_type not in stats["by_type"]:
                        stats["by_type"][content_type] = {"count": 0, "total_size": 0}
                    stats["by_type"][content_type]["count"] += 1
                    stats["by_type"][content_type]["total_size"] += file_size
                    
                    # 按状态统计
                    status = file.get("status", "unknown")
                    if status not in stats["by_status"]:
                        stats["by_status"][status] = 0
                    stats["by_status"][status] += 1
            
            return stats
                
        except Exception as e:
            logger.error(f"Error getting storage stats: {e}")
            return {
                "file_count": 0,
                "total_size": 0,
                "by_type": {},
                "by_status": {}
            }
    
    # ==================== Photo Version Management ====================

    async def save_photo_version(self, photo_version: PhotoVersion) -> PhotoVersion:
        """保存照片版本记录到数据库"""
        try:
            data = {
                "version_id": photo_version.version_id,
                "photo_id": photo_version.photo_id,
                "user_id": photo_version.user_id,
                "version_name": photo_version.version_name,
                "version_type": photo_version.version_type.value,
                "processing_mode": photo_version.processing_mode,
                "file_id": photo_version.file_id,
                "cloud_url": photo_version.cloud_url,
                "local_path": photo_version.local_path,
                "file_size": photo_version.file_size,
                "processing_params": photo_version.processing_params or {},
                "metadata": photo_version.metadata or {},
                "is_current": photo_version.is_current,
                "created_at": photo_version.created_at.isoformat() if photo_version.created_at else datetime.utcnow().isoformat(),
                "updated_at": datetime.utcnow().isoformat()
            }

            result = self.supabase.table("photo_versions").insert(data).execute()

            if result.data:
                logger.info(f"Saved photo version to database: {photo_version.version_id}")
                return PhotoVersion.model_validate(result.data[0])

            return photo_version
        except Exception as e:
            logger.error(f"Error saving photo version: {e}")
            raise

    async def get_photo_versions(self, photo_id: str, user_id: str) -> List[PhotoVersion]:
        """获取照片的所有版本"""
        try:
            logger.info(f"Getting photo versions for photo: {photo_id}")

            result = self.supabase.table("photo_versions").select("*").eq("photo_id", photo_id).eq("user_id", user_id).order("created_at", desc=True).execute()

            versions = []
            if result.data:
                for row in result.data:
                    versions.append(PhotoVersion.model_validate(row))

            return versions
        except Exception as e:
            logger.error(f"Error getting photo versions: {e}")
            return []

    async def get_photo_version(self, version_id: str, user_id: str) -> Optional[PhotoVersion]:
        """获取单个照片版本"""
        try:
            logger.info(f"Getting photo version: {version_id}")

            result = self.supabase.table("photo_versions").select("*").eq("version_id", version_id).eq("user_id", user_id).execute()

            if result.data and len(result.data) > 0:
                return PhotoVersion.model_validate(result.data[0])

            return None
        except Exception as e:
            logger.error(f"Error getting photo version: {e}")
            return None

    async def get_photo_info(self, photo_id: str) -> Dict[str, Any]:
        """获取照片基本信息（从storage_files表）"""
        try:
            logger.info(f"Getting photo info: {photo_id}")

            # Get file info from storage_files
            file_result = self.supabase.table(self.files_table).select("*").eq("file_id", photo_id).execute()

            if file_result.data and len(file_result.data) > 0:
                file_data = file_result.data[0]

                # Get current version from photo_versions
                version_result = self.supabase.table("photo_versions").select("version_id").eq("photo_id", photo_id).eq("is_current", True).execute()

                current_version_id = None
                if version_result.data and len(version_result.data) > 0:
                    current_version_id = version_result.data[0].get("version_id")

                return {
                    "title": file_data.get("file_name", "Untitled"),
                    "original_file_id": photo_id,
                    "current_version_id": current_version_id,
                    "created_at": file_data.get("uploaded_at"),
                    "updated_at": file_data.get("updated_at")
                }

            # Fallback if photo not found
            return {
                "title": "Photo",
                "original_file_id": photo_id,
                "current_version_id": None,
                "created_at": datetime.utcnow(),
                "updated_at": datetime.utcnow()
            }
        except Exception as e:
            logger.error(f"Error getting photo info: {e}")
            raise

    async def update_photo_current_version(self, photo_id: str, version_id: str) -> bool:
        """更新照片的当前版本"""
        try:
            logger.info(f"Updating photo {photo_id} current version to {version_id}")

            # First, set all versions of this photo to not current
            await self.update_version_current_flags(photo_id, version_id)

            return True
        except Exception as e:
            logger.error(f"Error updating photo current version: {e}")
            raise

    async def update_version_current_flags(self, photo_id: str, current_version_id: str) -> bool:
        """更新版本的当前标志"""
        try:
            logger.info(f"Updating version current flags for photo {photo_id}")

            # Set all versions to not current
            self.supabase.table("photo_versions").update({"is_current": False}).eq("photo_id", photo_id).execute()

            # Set the specified version as current
            self.supabase.table("photo_versions").update({"is_current": True, "updated_at": datetime.utcnow().isoformat()}).eq("version_id", current_version_id).execute()

            return True
        except Exception as e:
            logger.error(f"Error updating version current flags: {e}")
            raise

    async def get_original_version(self, photo_id: str) -> Optional[PhotoVersion]:
        """获取原始版本"""
        try:
            logger.info(f"Getting original version for photo: {photo_id}")

            result = self.supabase.table("photo_versions").select("*").eq("photo_id", photo_id).eq("version_type", PhotoVersionType.ORIGINAL.value).execute()

            if result.data and len(result.data) > 0:
                return PhotoVersion.model_validate(result.data[0])

            return None
        except Exception as e:
            logger.error(f"Error getting original version: {e}")
            return None

    async def delete_photo_version(self, version_id: str) -> bool:
        """删除照片版本"""
        try:
            logger.info(f"Deleting photo version: {version_id}")

            result = self.supabase.table("photo_versions").delete().eq("version_id", version_id).execute()

            return len(result.data) > 0 if result.data else False
        except Exception as e:
            logger.error(f"Error deleting photo version: {e}")
            return False

    # ==================== 数据库初始化 ====================
    
    async def check_connection(self) -> bool:
        """检查数据库连接"""
        try:
            result = self.supabase.table(self.files_table).select("count").limit(1).execute()
            return True
        except Exception as e:
            logger.error(f"Database connection check failed: {e}")
            return False

    # ==================== Album Management Methods ====================

    async def create_album(self, album_data: Dict[str, Any]) -> Dict[str, Any]:
        """创建相册"""
        try:
            result = self.supabase.table("albums").insert(album_data).execute()
            if result.data:
                logger.info(f"Created album: {album_data.get('album_id')}")
                return result.data[0]
            else:
                raise Exception("Failed to create album")
        except Exception as e:
            logger.error(f"Error creating album: {e}")
            raise

    async def get_album_by_id(self, album_id: str, user_id: str) -> Optional[Dict[str, Any]]:
        """根据ID获取相册（用户拥有的）"""
        try:
            result = self.supabase.table("albums").select("*").eq("album_id", album_id).eq("user_id", user_id).execute()
            return result.data[0] if result.data else None
        except Exception as e:
            logger.error(f"Error getting album {album_id}: {e}")
            return None

    async def get_album_by_id_any_user(self, album_id: str) -> Optional[Dict[str, Any]]:
        """根据ID获取相册（任何用户）- 用于家庭共享访问"""
        try:
            result = self.supabase.table("albums").select("*").eq("album_id", album_id).execute()
            return result.data[0] if result.data else None
        except Exception as e:
            logger.error(f"Error getting album {album_id}: {e}")
            return None

    async def list_user_albums(self, user_id: str, limit: int = 100, offset: int = 0) -> List[Dict[str, Any]]:
        """获取用户相册列表"""
        try:
            result = self.supabase.table("albums").select("*").eq("user_id", user_id).order("updated_at", desc=True).limit(limit).offset(offset).execute()
            return result.data if result.data else []
        except Exception as e:
            logger.error(f"Error listing albums for user {user_id}: {e}")
            return []

    async def update_album(self, album_id: str, user_id: str, updates: Dict[str, Any]) -> bool:
        """更新相册"""
        try:
            updates["updated_at"] = datetime.utcnow().isoformat()
            result = self.supabase.table("albums").update(updates).eq("album_id", album_id).eq("user_id", user_id).execute()
            return len(result.data) > 0 if result.data else False
        except Exception as e:
            logger.error(f"Error updating album {album_id}: {e}")
            return False

    async def delete_album(self, album_id: str, user_id: str) -> bool:
        """删除相册"""
        try:
            # 先删除相册照片关联
            await self.remove_all_photos_from_album(album_id)
            
            # 删除家庭成员
            await self.delete_album_family_members(album_id)
            
            # 删除相册
            result = self.supabase.table("albums").delete().eq("album_id", album_id).eq("user_id", user_id).execute()
            return len(result.data) > 0 if result.data else False
        except Exception as e:
            logger.error(f"Error deleting album {album_id}: {e}")
            return False

    async def add_photos_to_album(self, album_id: str, photo_ids: List[str], added_by: str) -> bool:
        """添加照片到相册"""
        try:
            current_time = datetime.utcnow().isoformat()
            
            photo_records = []
            for i, photo_id in enumerate(photo_ids):
                photo_records.append({
                    "album_id": album_id,
                    "photo_id": photo_id,
                    "added_by": added_by,
                    "added_at": current_time,
                    "is_featured": False,
                    "display_order": i,
                    "ai_tags": [],
                    "ai_objects": [],
                    "ai_scenes": [],
                    "sync_status": {}
                })
            
            result = self.supabase.table("album_photos").upsert(photo_records).execute()
            
            # 更新相册照片数量
            await self.update_album_photo_count(album_id)
            
            return len(result.data) > 0 if result.data else False
        except Exception as e:
            logger.error(f"Error adding photos to album {album_id}: {e}")
            return False

    async def get_album_photos(self, album_id: str, limit: int = 50, offset: int = 0) -> List[Dict[str, Any]]:
        """获取相册照片列表"""
        try:
            # 联表查询相册照片和文件信息
            result = self.supabase.table("album_photos").select(
                "*, storage_files(file_name, file_size, content_type, download_url, uploaded_at, metadata, tags)"
            ).eq("album_id", album_id).order("is_featured", desc=True).order("display_order").order("added_at", desc=True).limit(limit).offset(offset).execute()
            
            return result.data if result.data else []
        except Exception as e:
            logger.error(f"Error getting photos for album {album_id}: {e}")
            return []

    async def remove_all_photos_from_album(self, album_id: str) -> bool:
        """从相册中移除所有照片"""
        try:
            result = self.supabase.table("album_photos").delete().eq("album_id", album_id).execute()
            return True  # 删除操作总是返回True，即使没有记录被删除
        except Exception as e:
            logger.error(f"Error removing photos from album {album_id}: {e}")
            return False

    async def update_album_photo_count(self, album_id: str) -> bool:
        """更新相册照片数量"""
        try:
            # 获取照片数量
            count_result = self.supabase.table("album_photos").select("photo_id", count="exact").eq("album_id", album_id).execute()
            count = count_result.count if hasattr(count_result, 'count') else 0
            
            # 更新相册
            result = self.supabase.table("albums").update({
                "photo_count": count,
                "updated_at": datetime.utcnow().isoformat()
            }).eq("album_id", album_id).execute()
            
            return len(result.data) > 0 if result.data else False
        except Exception as e:
            logger.error(f"Error updating photo count for album {album_id}: {e}")
            return False

    async def add_family_member(self, member_data: Dict[str, Any]) -> Dict[str, Any]:
        """添加家庭成员"""
        try:
            result = self.supabase.table("family_members").insert(member_data).execute()
            if result.data:
                logger.info(f"Added family member: {member_data.get('member_id')}")
                return result.data[0]
            else:
                raise Exception("Failed to add family member")
        except Exception as e:
            logger.error(f"Error adding family member: {e}")
            raise

    async def get_album_family_members(self, album_id: str) -> List[Dict[str, Any]]:
        """获取相册家庭成员列表"""
        try:
            result = self.supabase.table("family_members").select("*").eq("album_id", album_id).order("created_at").execute()
            return result.data if result.data else []
        except Exception as e:
            logger.error(f"Error getting family members for album {album_id}: {e}")
            return []

    async def delete_album_family_members(self, album_id: str) -> bool:
        """删除相册的所有家庭成员"""
        try:
            result = self.supabase.table("family_members").delete().eq("album_id", album_id).execute()
            return True
        except Exception as e:
            logger.error(f"Error deleting family members for album {album_id}: {e}")
            return False

    async def get_album_sync_status(self, album_id: str, frame_id: str) -> Optional[Dict[str, Any]]:
        """获取相册同步状态"""
        try:
            result = self.supabase.table("album_sync_status").select("*").eq("album_id", album_id).eq("frame_id", frame_id).execute()
            return result.data[0] if result.data else None
        except Exception as e:
            logger.error(f"Error getting sync status for album {album_id}, frame {frame_id}: {e}")
            return None

    async def update_album_sync_status(self, album_id: str, frame_id: str, status_data: Dict[str, Any]) -> bool:
        """更新相册同步状态"""
        try:
            status_data["updated_at"] = datetime.utcnow().isoformat()
            
            # 尝试更新，如果不存在则插入
            result = self.supabase.table("album_sync_status").upsert({
                "album_id": album_id,
                "frame_id": frame_id,
                **status_data
            }).execute()
            
            return len(result.data) > 0 if result.data else False
        except Exception as e:
            logger.error(f"Error updating sync status for album {album_id}, frame {frame_id}: {e}")
            return False

    # ==================== Gallery & Slideshow Playlist Operations ====================
    
    async def create_playlist(self, playlist_data: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """创建播放列表"""
        try:
            playlist_id = f"playlist_{uuid.uuid4().hex[:16]}"
            data = {
                "playlist_id": playlist_id,
                **playlist_data,
                "created_at": datetime.utcnow().isoformat(),
                "updated_at": datetime.utcnow().isoformat()
            }
            result = self.supabase.table("slideshow_playlists").insert(data).execute()
            return result.data[0] if result.data else None
        except Exception as e:
            logger.error(f"Error creating playlist: {e}")
            return None
    
    async def get_playlist(self, playlist_id: str) -> Optional[Dict[str, Any]]:
        """获取播放列表"""
        try:
            result = self.supabase.table("slideshow_playlists").select("*").eq("playlist_id", playlist_id).execute()
            return result.data[0] if result.data else None
        except Exception as e:
            logger.error(f"Error getting playlist {playlist_id}: {e}")
            return None
    
    async def list_user_playlists(self, user_id: str) -> List[Dict[str, Any]]:
        """列出用户的播放列表"""
        try:
            result = self.supabase.table("slideshow_playlists").select("*").eq("user_id", user_id).order("updated_at", desc=True).execute()
            return result.data if result.data else []
        except Exception as e:
            logger.error(f"Error listing playlists for user {user_id}: {e}")
            return []
    
    async def update_playlist(self, playlist_id: str, updates: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """更新播放列表"""
        try:
            updates["updated_at"] = datetime.utcnow().isoformat()
            result = self.supabase.table("slideshow_playlists").update(updates).eq("playlist_id", playlist_id).execute()
            return result.data[0] if result.data else None
        except Exception as e:
            logger.error(f"Error updating playlist {playlist_id}: {e}")
            return None
    
    async def delete_playlist(self, playlist_id: str) -> bool:
        """删除播放列表"""
        try:
            self.supabase.table("slideshow_playlists").delete().eq("playlist_id", playlist_id).execute()
            return True
        except Exception as e:
            logger.error(f"Error deleting playlist {playlist_id}: {e}")
            return False
    
    # ==================== Photo Rotation Schedule Operations ====================
    
    async def create_rotation_schedule(self, schedule_data: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """创建轮播计划"""
        try:
            schedule_id = f"schedule_{uuid.uuid4().hex[:16]}"
            data = {
                "schedule_id": schedule_id,
                **schedule_data,
                "created_at": datetime.utcnow().isoformat(),
                "updated_at": datetime.utcnow().isoformat()
            }
            result = self.supabase.table("photo_rotation_schedules").insert(data).execute()
            return result.data[0] if result.data else None
        except Exception as e:
            logger.error(f"Error creating rotation schedule: {e}")
            return None
    
    async def get_frame_schedules(self, frame_id: str) -> List[Dict[str, Any]]:
        """获取设备的轮播计划"""
        try:
            result = self.supabase.table("photo_rotation_schedules").select("*").eq("frame_id", frame_id).eq("is_active", True).execute()
            return result.data if result.data else []
        except Exception as e:
            logger.error(f"Error getting schedules for frame {frame_id}: {e}")
            return []
    
    async def update_rotation_schedule(self, schedule_id: str, updates: Dict[str, Any]) -> bool:
        """更新轮播计划"""
        try:
            updates["updated_at"] = datetime.utcnow().isoformat()
            self.supabase.table("photo_rotation_schedules").update(updates).eq("schedule_id", schedule_id).execute()
            return True
        except Exception as e:
            logger.error(f"Error updating schedule {schedule_id}: {e}")
            return False
    
    # ==================== Photo Metadata Operations ====================
    
    async def get_photo_metadata(self, file_id: str) -> Optional[Dict[str, Any]]:
        """获取照片元数据"""
        try:
            result = self.supabase.table("photo_metadata").select("*").eq("file_id", file_id).execute()
            return result.data[0] if result.data else None
        except Exception as e:
            logger.error(f"Error getting photo metadata for {file_id}: {e}")
            return None
    
    async def upsert_photo_metadata(self, metadata: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """创建或更新照片元数据"""
        try:
            metadata["updated_at"] = datetime.utcnow().isoformat()
            if "created_at" not in metadata:
                metadata["created_at"] = datetime.utcnow().isoformat()
            
            result = self.supabase.table("photo_metadata").upsert(metadata).execute()
            return result.data[0] if result.data else None
        except Exception as e:
            logger.error(f"Error upserting photo metadata: {e}")
            return None
    
    async def get_favorite_photos(self, user_id: str, limit: int = 50) -> List[Dict[str, Any]]:
        """获取收藏照片"""
        try:
            # Join with storage_files to get user's favorite photos
            result = self.supabase.table("photo_metadata")\
                .select("file_id, is_favorite, rating, tags, quality_score")\
                .eq("is_favorite", True)\
                .limit(limit)\
                .execute()
            
            if not result.data:
                return []
            
            # Get file details
            file_ids = [item["file_id"] for item in result.data]
            files_result = self.supabase.table(self.files_table)\
                .select("*")\
                .eq("user_id", user_id)\
                .in_("file_id", file_ids)\
                .execute()
            
            return files_result.data if files_result.data else []
        except Exception as e:
            logger.error(f"Error getting favorite photos: {e}")
            return []
    
    # ==================== Photo Cache Operations ====================
    
    async def create_cache_entry(self, cache_data: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """创建缓存条目"""
        try:
            cache_id = f"cache_{uuid.uuid4().hex[:16]}"
            data = {
                "cache_id": cache_id,
                **cache_data,
                "created_at": datetime.utcnow().isoformat(),
                "updated_at": datetime.utcnow().isoformat()
            }
            result = self.supabase.table("photo_cache").upsert(data).execute()
            return result.data[0] if result.data else None
        except Exception as e:
            logger.error(f"Error creating cache entry: {e}")
            return None
    
    async def get_cache_entry(self, frame_id: str, photo_id: str) -> Optional[Dict[str, Any]]:
        """获取缓存条目"""
        try:
            result = self.supabase.table("photo_cache").select("*")\
                .eq("frame_id", frame_id)\
                .eq("photo_id", photo_id)\
                .execute()
            return result.data[0] if result.data else None
        except Exception as e:
            logger.error(f"Error getting cache entry: {e}")
            return None
    
    async def get_frame_cache_stats(self, frame_id: str) -> Dict[str, Any]:
        """获取设备缓存统计"""
        try:
            result = self.supabase.table("photo_cache").select("*").eq("frame_id", frame_id).execute()
            
            if not result.data:
                return {
                    "total_cached": 0,
                    "total_size_bytes": 0,
                    "cache_hit_rate": 0.0,
                    "pending_count": 0,
                    "failed_count": 0
                }
            
            total_cached = sum(1 for item in result.data if item["status"] == "cached")
            total_size = sum(item.get("file_size", 0) or 0 for item in result.data if item["status"] == "cached")
            total_hits = sum(item.get("hit_count", 0) for item in result.data)
            total_accesses = total_hits + len(result.data)
            hit_rate = total_hits / total_accesses if total_accesses > 0 else 0.0
            pending = sum(1 for item in result.data if item["status"] == "pending")
            failed = sum(1 for item in result.data if item["status"] == "failed")
            
            return {
                "total_cached": total_cached,
                "total_size_bytes": total_size,
                "cache_hit_rate": hit_rate,
                "pending_count": pending,
                "failed_count": failed,
                "oldest_cache": min((item["cached_at"] for item in result.data if item.get("cached_at")), default=None),
                "newest_cache": max((item["cached_at"] for item in result.data if item.get("cached_at")), default=None)
            }
        except Exception as e:
            logger.error(f"Error getting cache stats: {e}")
            return {"total_cached": 0, "total_size_bytes": 0, "cache_hit_rate": 0.0}
    
    async def update_cache_status(self, cache_id: str, status: str, cached_url: Optional[str] = None, error: Optional[str] = None) -> bool:
        """更新缓存状态"""
        try:
            updates = {
                "status": status,
                "updated_at": datetime.utcnow().isoformat()
            }
            if cached_url:
                updates["cached_url"] = cached_url
                updates["cached_at"] = datetime.utcnow().isoformat()
            if error:
                updates["error_message"] = error
            
            self.supabase.table("photo_cache").update(updates).eq("cache_id", cache_id).execute()
            return True
        except Exception as e:
            logger.error(f"Error updating cache status: {e}")
            return False
    
    async def clean_expired_cache(self, frame_id: str, days_old: int = 30) -> int:
        """清理过期缓存"""
        try:
            expiry_date = datetime.utcnow() - timedelta(days=days_old)
            result = self.supabase.table("photo_cache")\
                .delete()\
                .eq("frame_id", frame_id)\
                .lt("cached_at", expiry_date.isoformat())\
                .execute()
            return len(result.data) if result.data else 0
        except Exception as e:
            logger.error(f"Error cleaning expired cache: {e}")
            return 0
    
    async def increment_cache_hit(self, cache_id: str) -> bool:
        """增加缓存命中计数"""
        try:
            # Get current hit count
            result = self.supabase.table("photo_cache").select("hit_count").eq("cache_id", cache_id).execute()
            if result.data:
                hit_count = result.data[0].get("hit_count", 0) + 1
                self.supabase.table("photo_cache").update({
                    "hit_count": hit_count,
                    "last_accessed_at": datetime.utcnow().isoformat()
                }).eq("cache_id", cache_id).execute()
                return True
            return False
        except Exception as e:
            logger.error(f"Error incrementing cache hit: {e}")
            return False