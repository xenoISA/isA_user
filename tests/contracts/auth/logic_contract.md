# Authentication Service - Logic Contract

## Business Rules (50 rules)

### Token Verification Rules (BR-TOK-001 to BR-TOK-010)

**BR-TOK-001: Multi-Provider Support**
- System MUST support verification of Auth0 and isa_user tokens
- Provider can be auto-detected from token issuer claim
- If provider is specified, it takes precedence over auto-detection
- Unsupported providers return error: "Unsupported provider: {provider}"
- Default fallback: isa_user provider

**BR-TOK-002: Token Expiration**
- Expired tokens MUST be rejected with "Token expired" error
- System checks exp claim against current UTC time
- No grace period for expiration
- Expiration check occurs before any business logic
- Valid=false returned for expired tokens

**BR-TOK-003: Token Signature Validation**
- Auth0 tokens validated with JWKS public key (RS256)
- isa_user tokens validated with JWT_SECRET (HS256)
- Invalid signatures rejected immediately
- Signature verification occurs before claim extraction
- Returns "Invalid token" error on signature mismatch

**BR-TOK-004: Claims Extraction**
- Valid tokens return user_id, email, organization_id, permissions
- Missing optional claims return null/default values
- Claims structure depends on provider (standardized in response)
- Metadata and permissions extracted as JSONB/arrays
- Token type claim validated for operation context

**BR-TOK-005: Access Token Expiration**
- Access tokens expire in 1 hour (3600 seconds)
- Expiration time set during token creation
- Cannot be extended without refresh
- iat (issued at) timestamp recorded
- exp calculated as iat + 3600

**BR-TOK-006: Refresh Token Expiration**
- Refresh tokens expire in 7 days (604800 seconds)
- Used to obtain new access tokens
- Refresh tokens contain minimal claims (user_id, email, token_type)
- exp calculated as iat + 604800
- No rotation of refresh tokens (stateless)

**BR-TOK-007: Token Type Validation**
- Access tokens have token_type="access"
- Refresh tokens have token_type="refresh"
- Device tokens have type="device"
- Wrong type rejected for operation
- Token type checked before processing refresh/verification

**BR-TOK-008: JTI Uniqueness**
- Every token has unique JTI (JWT ID)
- Used for token tracking and revocation
- Generated as UUID
- Included in token claims
- Enables audit trail correlation

**BR-TOK-009: Token Provider Detection**
- Issuer "isA_user" -> isa_user provider
- Issuer contains "auth0.com" -> Auth0 provider
- Default fallback: isa_user
- Detection uses unverified decode (signature check comes after)
- Provider returned in verification response

**BR-TOK-010: JWKS Caching**
- Auth0 JWKS fetched from /.well-known/jwks.json
- Public keys cached for performance (implementation-specific TTL)
- Cache invalidation on verification failure
- kid (key ID) matching from token header
- RS256 algorithm used for Auth0 verification

### Registration Rules (BR-REG-001 to BR-REG-010)

**BR-REG-011: Email Validation**
- Email MUST be valid format (basic validation)
- Email normalized (lowercase, trimmed)
- Duplicate emails handled by account service (409 Conflict)
- Email format: user@domain.tld
- Email stored in lowercase

**BR-REG-012: Password Requirements**
- Minimum length: 8 characters
- No maximum length enforcement
- Password strength validation (future enhancement)
- Passwords not hashed in current implementation (placeholder)
- Should contain mix of characters (future enhancement)

**BR-REG-013: Verification Code Generation**
- Code is 6 digits (000000 to 999999)
- Generated using secrets.randbelow(1000000)
- Format: zero-padded 6-digit string
- New code generated for each registration attempt
- Stored in pending registrations dictionary

**BR-REG-014: Verification Code Expiration**
- Codes expire in 10 minutes (600 seconds)
- Expired codes rejected with error: "Verification expired"
- Cleanup on expiration check
- Expiration checked before code comparison
- expires_at stored as datetime with timezone

**BR-REG-015: Pending Registration Storage**
- Stored in-memory with pending_registration_id
- Contains email, password, name, code, expires_at, verified flag
- pending_registration_id format: uuid4().hex
- Cleaned up after successful verification or expiration
- Production should use Redis for multi-replica support

**BR-REG-016: User ID Generation**
- Format: usr_{uuid_hex}
- Generated by auth service (ID authority)
- Unique across system (UUID4-based)
- Created after successful verification
- Used as primary identifier in account creation

**BR-REG-017: Account Creation**
- On successful verification, create account via AccountClient
- Use ensure_account endpoint for idempotency
- Pass user_id, email, name, subscription_plan="free"
- Account creation failure rolls back registration
- Error returned if account service unavailable

**BR-REG-018: Token Issuance on Registration**
- Issue access + refresh token pair immediately
- User logged in after verification
- No additional login step required
- Tokens include user_id, email, provider="isa_user"
- Registration metadata included in token claims

**BR-REG-019: Email Notification**
- Verification code sent via NotificationService
- Email contains 6-digit code and expiration time
- Failure to send email does not fail registration (code still valid)
- Email type: "email", priority: "high"
- Tags: ["registration", "verification"]

**BR-REG-020: Registration Event**
- Publish user.logged_in event after account creation
- Contains user_id, email, timestamp, provider
- Consumed by session, audit, analytics services
- Event publishing failure logged but doesn't fail registration
- Event source: "auth_service"

### Device Authentication Rules (BR-DEV-001 to BR-DEV-010)

**BR-DEV-021: Device Secret Generation**
- 32-byte URL-safe secret generated on registration
- Generated using secrets.token_urlsafe(32)
- Returned once during registration (plaintext)
- Hashed with SHA-256 before storage
- Never retrievable after registration

**BR-DEV-022: Device Secret Hashing**
- Secrets hashed with SHA-256
- Only hash stored in database
- Plaintext never persisted
- Hash comparison for authentication
- hashlib.sha256(secret.encode()).hexdigest()

**BR-DEV-023: Device Organization Binding**
- Device MUST be bound to organization
- Organization ID required on registration
- Cannot change organization after registration
- Organization ownership verified for operations
- Device tokens scoped to organization_id

**BR-DEV-024: Device Token Generation**
- Device tokens contain device_id, organization_id, device_type
- Tokens expire in 24 hours (86400 seconds)
- Type claim set to "device"
- HS256 signing with JWT_SECRET
- iat and exp timestamps included

**BR-DEV-025: Device Status**
- Status: active, inactive, revoked
- Only active devices can authenticate
- Revoked devices permanently disabled
- Status stored in device_credentials table
- Status checked during authentication

**BR-DEV-026: Device Pairing Token Generation**
- Pairing tokens are URL-safe random (32 bytes)
- Expire in 5 minutes (300 seconds)
- Single-use only (used flag)
- Generated using secrets.token_urlsafe(32)
- Stored in device_pairing_tokens table

**BR-DEV-027: Device Pairing Verification**
- Token must match device_id
- Token must not be expired
- Token must not be used
- Mark token as used on successful verification
- user_id recorded in paired_user_id field

**BR-DEV-028: Device Secret Refresh**
- New secret generated and returned
- Old secret invalidated immediately
- Requires organization ownership verification
- Returns plaintext new secret once
- Updates device_secret hash in database

**BR-DEV-029: Device Revocation**
- Revoked devices cannot authenticate
- Revocation is permanent (status=revoked)
- Requires organization ownership verification
- Existing tokens remain valid until expiry (stateless)
- Revocation status checked during authentication

**BR-DEV-030: Device Authentication Events**
- Publish device.registered on registration
- Publish device.authenticated on login
- Publish device.pairing_completed on pairing verification
- Events include device_id, organization_id, timestamp
- Event source: ServiceSource.AUTH_SERVICE

### API Key Rules (BR-API-001 to BR-API-010)

**BR-API-031: API Key Generation**
- Format: isa_ak_{url_safe_token} (implementation varies)
- 32-byte random token using secrets.token_urlsafe(32)
- Returned once during creation
- Key ID generated as unique identifier
- Stored with metadata in organizations.api_keys JSONB

**BR-API-032: API Key Hashing**
- Keys hashed before storage
- Only hash stored in organizations.api_keys JSONB
- Plaintext never persisted
- SHA-256 hashing algorithm
- Hash comparison for verification

**BR-API-033: Organization Scoping**
- API keys scoped to organization
- Cannot access other organization data
- Organization ID embedded in key metadata
- Organization existence validated before creation
- Organization ownership verified for operations

**BR-API-034: Permission Lists**
- Keys can have permission restrictions
- Empty list = no restrictions (full access)
- Permissions checked on each request
- Permissions stored as array in key metadata
- Returned during verification for enforcement

**BR-API-035: API Key Expiration**
- Keys can have optional expiration date
- expires_days parameter (1-365 typical)
- Expired keys rejected on verification
- expires_at calculated as now + timedelta(days=expires_days)
- Expiration checked before hash comparison

**BR-API-036: Key Status**
- Keys have is_active flag
- Inactive keys rejected on verification
- Revocation sets is_active=false
- Active status required for verification
- Status persisted in JSONB metadata

**BR-API-037: Last-Used Tracking**
- Update last_used timestamp on successful verification
- Used for audit and cleanup
- Updated asynchronously (non-blocking)
- Timestamp stored in key metadata
- Enables unused key detection

**BR-API-038: Key Verification**
- Hash provided key and compare with stored hash
- Check expiration and is_active
- Return organization_id and permissions on success
- Update last_used timestamp
- Return validation result with key metadata

**BR-API-039: Key Revocation**
- Set is_active=false
- Revoked keys cannot be reactivated
- Must create new key
- Requires organization ownership verification
- Permanent soft delete (kept for audit)

**BR-API-040: Key Listing**
- List all keys for organization
- Do not return key hash or plaintext
- Include metadata (name, permissions, last_used)
- Filter by is_active if needed
- Return key_id for management operations

### Session Management Rules (BR-SES-001 to BR-SES-005)

**BR-SES-041: Session Creation**
- Create session on token pair generation (future implementation)
- Store access_token, refresh_token, expires_at
- Generate unique session_id
- Session tracked for user.logged_in events
- Enables session management and invalidation

**BR-SES-042: Session Activity Tracking**
- Update last_activity on each authenticated request (future)
- Used for idle timeout
- Updated asynchronously
- Enables session analytics
- Supports concurrent session monitoring

**BR-SES-043: Session Invalidation**
- Set is_active=false on logout (future)
- Record invalidated_at timestamp
- Invalidated sessions cannot be reactivated
- Supports "logout everywhere" functionality
- Token blacklist for immediate invalidation

**BR-SES-044: Session Expiration**
- Sessions expire when refresh_token expires
- 7-day default expiration (604800 seconds)
- Expired sessions automatically invalidated
- Cleanup of expired sessions (background job)
- Expiration aligned with refresh token TTL

**BR-SES-045: Session Lookup**
- Sessions retrieved by session_id (future)
- Only return active sessions
- Filter by user_id for user's sessions
- Support pagination for large session lists
- Enable session revocation by ID

### Token Claims Rules (BR-CLM-001 to BR-CLM-005)

**BR-CLM-046: Standard Claims**
- iss (issuer): "isA_user" for custom tokens
- sub (subject): user_id or device_id
- iat (issued at): token creation timestamp (Unix time)
- exp (expires): token expiration timestamp (Unix time)
- jti (JWT ID): unique token identifier (UUID)

**BR-CLM-047: Custom Claims for User Tokens**
- user_id: unique user identifier
- email: user email address
- organization_id: optional organization context (null if none)
- scope: token scope (user, device, service)
- token_type: access or refresh
- permissions: array of granted permissions
- metadata: JSONB custom data

**BR-CLM-048: Custom Claims for Device Tokens**
- device_id: unique device identifier
- organization_id: owning organization (required)
- device_type: device category (display, camera, sensor, gateway)
- type: "device" (distinguishes from user tokens)
- No email or user_id claims

**BR-CLM-049: Metadata Structure**
- Flexible JSONB structure
- Common fields: subscription_level, registration method
- Provider-specific metadata preserved
- Not validated beyond JSON format
- Optional field, defaults to empty object

**BR-CLM-050: Permissions Array**
- List of string permission identifiers
- Format: "action:resource" (e.g., "read:albums")
- Empty array = no specific permissions
- Not interpreted by auth service (authorization service responsibility)
- Preserved in token for downstream services

## State Machines (3 state machines)

### 1. Token Lifecycle State Machine

```
States:
- CREATED: Token just generated, encoded but not yet used
- ACTIVE: Token valid, signature verified, not expired
- EXPIRED: Token past expiration time (exp < now)
- REFRESHED: Access token refreshed using refresh token (for access tokens only)
- REVOKED: Token manually revoked (future implementation with blacklist)

Transitions:
CREATED -> ACTIVE (on first verification/use)
ACTIVE -> EXPIRED (when current_time >= exp)
ACTIVE -> REFRESHED (for access tokens, via refresh endpoint)
ACTIVE -> REVOKED (manual revocation via blacklist - future)
EXPIRED -> [terminal state, cannot transition]
REFRESHED -> [terminal state, old token invalid]
REVOKED -> [terminal state, permanently invalid]

Rules:
- Once expired, cannot be refreshed or reactivated
- Refresh tokens can refresh access tokens multiple times (stateless)
- Access tokens cannot be extended, only refreshed via refresh token
- Token state is stateless (determined by exp claim and blacklist check)
- Blacklist required for immediate revocation (future implementation)

State Determination Logic:
1. Check signature validity (invalid -> error, not state)
2. Check exp claim: if exp < now -> EXPIRED
3. Check blacklist (future): if blacklisted -> REVOKED
4. Check token_type for refresh operations
5. Otherwise -> ACTIVE

Example Flow:
User Login -> Create Token (CREATED) -> First API Call (ACTIVE) ->
After 1h (EXPIRED) -> Refresh Call (new token CREATED, old REFRESHED) ->
New Token Used (ACTIVE)
```

### 2. Device Registration State Machine

```
States:
- UNREGISTERED: Device does not exist in system
- REGISTERED: Device credentials created, secret issued
- ACTIVE: Device successfully authenticated at least once
- PAIRED: Device paired with user account via pairing token
- INACTIVE: Device deactivated temporarily (status=inactive)
- REVOKED: Device credentials permanently revoked (status=revoked)

Transitions:
UNREGISTERED -> REGISTERED (POST /device/register, secret returned)
REGISTERED -> ACTIVE (POST /device/authenticate, first successful auth)
ACTIVE -> PAIRED (POST /device/pairing-token/verify)
ACTIVE -> INACTIVE (manual deactivation - future)
ACTIVE -> REVOKED (DELETE /device/{device_id}, permanent)
INACTIVE -> ACTIVE (manual reactivation - future)
INACTIVE -> REVOKED (DELETE /device/{device_id})
PAIRED -> ACTIVE (no state change, pairing is metadata)
PAIRED -> REVOKED (DELETE /device/{device_id})
REVOKED -> [terminal state, cannot be reversed]

Rules:
- Device can only be registered once (device_id unique constraint)
- Secret only shown during REGISTERED state
- Device can authenticate from REGISTERED or ACTIVE states
- Pairing is optional (devices can function without user pairing)
- Pairing doesn't change authentication capability
- INACTIVE state prevents authentication (status check)
- REVOKED devices cannot authenticate (permanent)
- Revocation is irreversible (must register new device)

State Storage:
- status field: "active" (REGISTERED/ACTIVE/PAIRED), "inactive", "revoked"
- Pairing tracked separately in device_pairing_tokens table
- ACTIVE vs REGISTERED distinguished by last_authenticated timestamp

Example Flow:
Setup -> Register (UNREGISTERED->REGISTERED, secret returned) ->
Store Secret -> Authenticate (REGISTERED->ACTIVE) ->
Display QR (generate pairing token) -> User Scans (ACTIVE->PAIRED) ->
Continue Operation (PAIRED/ACTIVE) ->
Security Incident -> Revoke (PAIRED->REVOKED, cannot authenticate)
```

### 3. Registration Verification State Machine

```
States:
- NOT_STARTED: No pending registration exists
- STARTED: Registration initiated, pending_id created
- PENDING: Awaiting verification code, email sent
- CODE_SENT: Verification code delivered via email
- VERIFIED: Code verified successfully
- EXPIRED: Verification code expired (>10 minutes)
- FAILED: Verification failed (wrong code, but can retry)
- COMPLETED: Account created, tokens issued

Transitions:
NOT_STARTED -> STARTED (POST /register, email/password submitted)
STARTED -> PENDING (code generated, stored in-memory)
PENDING -> CODE_SENT (notification service called, email sent)
CODE_SENT -> VERIFIED (POST /verify, correct code submitted)
CODE_SENT -> FAILED (POST /verify, incorrect code, retry allowed)
CODE_SENT -> EXPIRED (10 minutes elapsed, pending_id deleted)
FAILED -> VERIFIED (POST /verify, correct code after retry)
VERIFIED -> COMPLETED (account created, tokens issued, cleanup)
EXPIRED -> [terminal state, must restart registration]
COMPLETED -> [terminal state, user account active]

Rules:
- Maximum 10-minute window for verification
- No explicit limit on retry attempts (within expiration window)
- Expired registrations require fresh start (new pending_id)
- Verified registrations trigger account creation
- Email send failure doesn't fail registration (code still valid)
- pending_registration_id required for verification
- Code comparison is case-sensitive (digits only)
- Cleanup occurs on: VERIFIED, EXPIRED
- Account creation failure reverts to FAILED (no tokens issued)

State Storage:
- In-memory dict: _pending_registrations[pending_id]
- Fields: email, password, name, code, expires_at, verified flag
- verified=False (PENDING/CODE_SENT/FAILED)
- verified=True (VERIFIED, before cleanup)
- Deleted entry (EXPIRED, COMPLETED)

Error Handling:
- Invalid pending_id -> "Invalid pending registration"
- Expired (expires_at < now) -> "Verification expired", cleanup
- Wrong code -> "Invalid verification code", no state change
- Account creation error -> "Account creation failed", revert to FAILED

Example Flow:
User -> Enter Email/Password (NOT_STARTED->STARTED) ->
Generate Code (STARTED->PENDING) ->
Send Email (PENDING->CODE_SENT) ->
User Enters Wrong Code (CODE_SENT->FAILED) ->
User Enters Correct Code (FAILED->VERIFIED) ->
Create Account (VERIFIED->COMPLETED) ->
Return Tokens (user logged in)

Alternative: Expiration Flow:
CODE_SENT -> Wait 11 minutes -> (Automatic) EXPIRED ->
User tries to verify -> "Verification expired" ->
Must restart from NOT_STARTED
```

## Edge Cases (15 cases)

**EC-001: Expired Token Verification**
- Input: Token with exp claim in the past
- Expected: Return {valid: false, error: "Token expired"}
- Actual behavior: Correctly rejects via jwt.ExpiredSignatureError
- Response: HTTP 200 with valid=false (not 401)
- Token claims not extracted after expiration check

**EC-002: Missing Provider Hint**
- Input: Token without provider parameter
- Expected: Auto-detect from issuer claim
- Actual behavior: Uses _detect_provider() logic
- Issuer decode: jwt.decode(token, options={"verify_signature": False})
- Fallback: Returns "isa_user" if detection fails

**EC-003: Unsupported Provider**
- Input: provider="unknown_provider"
- Expected: Return {valid: false, error: "Unsupported provider: unknown_provider"}
- Actual behavior: Correctly rejects in verify_token routing
- No signature verification attempted
- Logs error for monitoring

**EC-004: Duplicate Email Registration**
- Input: Register with existing email
- Expected: Account service rejects with 409 Conflict
- Actual behavior: Registration fails at verify_registration stage
- Error: "Account creation failed"
- Account service ensure endpoint returns existing account or error
- Pending registration cleaned up

**EC-005: Expired Verification Code**
- Input: Submit code after 10 minutes
- Expected: Return {success: false, error: "Verification expired"}
- Actual behavior: Cleanup and reject
- Check: record["expires_at"] < datetime.now(timezone.utc)
- Pending registration deleted from memory
- User must restart registration flow

**EC-006: Wrong Verification Code**
- Input: Submit incorrect 6-digit code
- Expected: Return {success: false, error: "Invalid verification code"}
- Actual behavior: Allow retry until expiration
- Code comparison: str(code).strip() != str(record["code"]).strip()
- Pending registration remains valid
- No retry limit enforced (expiration is limit)

**EC-007: Device Secret Mismatch**
- Input: Authenticate with wrong device secret
- Expected: Return {authenticated: false, error: "Invalid device credentials"}
- Actual behavior: Hash comparison fails
- Process: hash provided secret, compare with stored hash
- No indication whether device_id or secret is wrong (security)
- Returns generic error message

**EC-008: Expired Pairing Token**
- Input: Verify pairing token after 5 minutes
- Expected: Return {valid: false, error: "Token has expired"}
- Actual behavior: Correctly rejects
- Check: token_data['expires_at'] < datetime.now(timezone.utc)
- Token remains in database (not cleaned up immediately)
- User must generate new pairing token

**EC-009: Reused Pairing Token**
- Input: Verify already-used pairing token
- Expected: Return {valid: false, error: "Token has already been used"}
- Actual behavior: Correctly rejects
- Check: token_data['used'] == True
- paired_user_id and paired_at already set
- Prevents replay attacks

**EC-010: API Key from Wrong Organization**
- Input: Verify API key, check organization_id mismatch
- Expected: Return {valid: false} or not found
- Actual behavior: Organization ID in key metadata prevents cross-org access
- Verification only succeeds if stored organization_id matches
- Hash lookup scoped to organization
- No error reveals existence of key in other orgs

**EC-011: Revoked API Key Verification**
- Input: Verify API key with is_active=false
- Expected: Return {valid: false, error: "Invalid or expired API key"}
- Actual behavior: Correctly rejects
- Check: key metadata is_active field
- Revoked keys remain in database for audit
- Generic error message (doesn't reveal revocation)

**EC-012: Refresh Token Used Multiple Times**
- Input: Use same refresh token twice
- Expected: Both attempts succeed (stateless refresh)
- Actual behavior: Refresh token not consumed, can be reused
- Note: No single-use enforcement (stateless JWT)
- Future: Implement refresh token rotation for security
- Current: Refresh token valid until expiration

**EC-013: Device Token Used for User Endpoint**
- Input: Use device token (type="device") for user endpoint
- Expected: Return 401 Unauthorized or validation error
- Actual behavior: Token type validation should reject
- Check: payload.get('type') == 'device' vs expected user token
- Implementation-specific per endpoint
- Device tokens lack user_id and email claims

**EC-014: Missing JWT Manager**
- Input: Call token operation with jwt_manager=None
- Expected: Return {success: false, error: "JWT manager not available"}
- Actual behavior: Graceful error handling
- Check: if not self.jwt_manager before operations
- Prevents AttributeError on None.create_token()
- Occurs if AuthenticationService initialized without dependencies

**EC-015: Account Service Unavailable**
- Input: Register user when account service down
- Expected: Return {success: false, error: "Account creation failed"}
- Actual behavior: Exception caught in verify_registration
- Registration fails, user can retry
- Pending registration remains valid (can re-verify)
- Error logged for monitoring

## Data Consistency Rules

**DC-001: Email Normalization**
- All emails converted to lowercase
- Leading/trailing whitespace stripped
- Normalization: email.strip().lower()
- Ensures case-insensitive matching
- Applied before storage and comparison
- Consistent across registration and verification

**DC-002: Timestamp UTC**
- All timestamps stored in UTC
- Timezone-aware datetime objects
- Creation: datetime.now(timezone.utc)
- Expiration checks use UTC
- ISO format for API responses: .isoformat()
- No timezone conversion in business logic

**DC-003: Secret Hashing Consistency**
- Device secrets: SHA-256 hash (hashlib.sha256)
- API keys: SHA-256 hash
- Hashing: hashlib.sha256(secret.encode()).hexdigest()
- Same algorithm throughout service
- Hex digest format for storage
- Comparison: hash(provided) == stored_hash

**DC-004: Token ID Uniqueness**
- JTI (JWT ID) unique per token
- Generated as UUID (uuid4)
- Prevents token replay attacks
- Enables token revocation by ID (future)
- Included in all JWT tokens
- Correlation with audit logs

**DC-005: Session ID Format**
- Format: ses_{uuid} or uuid.hex (future implementation)
- Unique across all sessions
- Used for session lookup
- Generated on token pair creation
- Enables session management operations
- No collision with user_id or device_id formats

**DC-006: Pending Registration ID Format**
- Format: uuid4().hex (32 character hex string)
- Unique pending registration identifier
- Generated on start_registration
- No prefix (unlike user_id with usr_ prefix)
- Used as key in _pending_registrations dict
- Deleted after verification or expiration

**DC-007: Device ID Format**
- No enforced format (client-provided)
- Must be unique globally (database constraint)
- Typically: device type prefix + identifier
- Example: "emoframe_001", "dev_camera_abc123"
- Stored as-is, no normalization
- Used in device tokens and pairing

**DC-008: User ID Format**
- Format: usr_{uuid_hex}
- Generated by auth service (ID authority)
- uuid_hex: uuid.uuid4().hex (32 characters)
- Total length: 3 (prefix) + 1 (underscore) + 32 = 36 characters
- Unique across system
- Immutable after creation

**DC-009: Organization ID Format**
- Format: org_{identifier} (assumed from context)
- Provided by organization service
- Validated before device/API key operations
- Nullable for users (optional organization membership)
- Stored in tokens and device credentials
- Foreign key relationship (logical, not enforced)

**DC-010: Token Type Values**
- Access tokens: token_type="access"
- Refresh tokens: token_type="refresh"
- Device tokens: type="device" (different claim name)
- Bearer tokens: token_type field in response = "Bearer"
- Enum-like validation (string comparison)
- Case-sensitive comparison

## Integration Contracts

### AccountService Integration

**Endpoint**: POST /api/v1/accounts/ensure

**When**: After successful registration verification

**Purpose**: Create or retrieve user account profile

**Request Payload**:
```json
{
  "user_id": "usr_abc123",
  "email": "user@example.com",
  "name": "User Name",
  "subscription_plan": "free"
}
```

**Expected Success Response**: 200 OK
```json
{
  "user_id": "usr_abc123",
  "email": "user@example.com",
  "name": "User Name",
  "subscription_plan": "free",
  "is_active": true,
  "created_at": "2025-12-13T12:00:00Z"
}
```

**Expected Conflict Response**: 409 Conflict (if user_id exists)
```json
{
  "detail": "Account already exists",
  "user_id": "usr_abc123"
}
```

**Error Handling**:
- Retry on 500 Internal Server Error (transient failure)
- Fail registration on 400 Bad Request (validation error)
- Fail registration on 422 Unprocessable Entity (invalid data)
- Log warning and continue if account service unavailable (dev mode)
- Exception caught and returns "Account creation failed"

**Idempotency**:
- ensure endpoint is idempotent
- Safe to call multiple times with same user_id
- Returns existing account if already created
- No duplicate account creation

**Timeout**: 10 seconds (httpx client default)

**Fallback Behavior**:
- If account_client is None, create minimal account dict locally
- Registration continues with tokens issued
- Warning logged for missing account service

### NotificationService Integration

**Endpoint**: POST /api/v1/notifications/send

**When**: After start_registration, before returning pending_id

**Purpose**: Send verification code email to user

**Request Payload**:
```json
{
  "type": "email",
  "recipient_email": "user@example.com",
  "subject": "Your verification code",
  "content": "Your verification code is 123456. It expires in 10 minutes.",
  "html_content": "<p>Your verification code is <b>123456</b>. It expires in 10 minutes.</p>",
  "priority": "high",
  "metadata": {
    "category": "user_registration",
    "pending_registration_id": "abc123"
  },
  "tags": ["registration", "verification"]
}
```

**Expected Success Response**: 202 Accepted
```json
{
  "success": true,
  "notification_id": "notif_xyz789",
  "status": "queued"
}
```

**Error Handling**:
- Log warning on failure: "Failed to send verification email: {error}"
- Continue registration (code still valid)
- User can verify using code even if email failed
- No retry logic (fire-and-forget)
- Exception caught, doesn't fail start_registration

**Timeout**: 10 seconds

**Fallback Behavior**:
- If notification_client is None, skip email send
- Registration continues normally
- User must be informed of code through other means (dev/test mode)

**Dependencies**:
- Notification service must be running
- Email provider configured (SMTP, SendGrid, etc.)
- Email templates available

### NATS Event Publishing

**Events Published**:
1. user.logged_in (after token pair generation)
2. device.registered (after device registration)
3. device.authenticated (after device authentication)
4. device.pairing_completed (after pairing verification)

**Event Format** (using Event class):
```python
Event(
    event_type=EventType.USER_LOGGED_IN,
    source=ServiceSource.AUTH_SERVICE,
    data={
        "user_id": "usr_abc123",
        "email": "user@example.com",
        "organization_id": "org_xyz789",
        "timestamp": "2025-12-13T12:00:00Z",
        "provider": "isa_user"
    },
    metadata={
        "permissions": "read:albums,write:photos",
        "has_organization": "true"
    }
)
```

**NATS Subject Pattern**:
- events.user.logged_in
- events.device.registered
- events.device.authenticated
- events.device.pairing_completed

**Expected Behavior**:
- Async publish (non-blocking)
- No acknowledgment required (fire-and-forget)
- Subscribers: session_service, audit_service, analytics_service, device_service

**Error Handling**:
- Log error on publish failure: "Failed to publish {event_type} event: {error}"
- Don't fail operation if event publishing fails
- Event loss acceptable (not critical for operation)
- Monitor event publish failures for reliability

**Fallback Behavior**:
- If event_bus is None, skip event publishing
- Operation continues successfully
- Warning logged for missing event bus

**Retry Policy**: None (fire-and-forget)

**Event Payload Guidelines**:
- Always include timestamp in ISO format
- Always include source service identifier
- Always include primary entity ID (user_id, device_id)
- Metadata is optional, used for additional context
- Keep payload size < 1MB (NATS limit)

### OrganizationService Integration (Implied)

**Purpose**: Validate organization existence for API keys and devices

**Assumed Endpoint**: GET /api/v1/organizations/{org_id}

**When**: Before creating API key or registering device

**Expected Response**: 200 OK with organization data, or 404 Not Found

**Error Handling**:
- Fail operation if organization not found
- Return error: "Organization not found"
- No creation of orphaned resources

**Note**: Not explicitly implemented in current code, but logical dependency

## Error Handling Contracts

### Token Verification Errors

**Invalid Signature**:
```json
{
  "valid": false,
  "error": "Invalid token: {jwt.InvalidTokenError message}"
}
```
- HTTP Status: 200 (error in body, not status)
- Cause: Signature verification failed
- User Action: Obtain new token

**Expired Token**:
```json
{
  "valid": false,
  "error": "Token expired"
}
```
- HTTP Status: 200 (error in body, not status)
- Cause: exp < current UTC time
- User Action: Refresh access token or re-authenticate

**Missing Claims**:
```json
{
  "valid": false,
  "error": "Invalid token structure"
}
```
- HTTP Status: 200
- Cause: Required claims missing (sub, iat, exp)
- User Action: Obtain valid token

**Unsupported Provider**:
```json
{
  "valid": false,
  "error": "Unsupported provider: {provider}"
}
```
- HTTP Status: 200
- Cause: Provider not in (auth0, isa_user, local)
- User Action: Check provider configuration

**JWT Manager Unavailable**:
```json
{
  "valid": false,
  "error": "JWT manager not available"
}
```
- HTTP Status: 200
- Cause: jwt_manager dependency not injected
- User Action: Service configuration issue

### Registration Errors

**Invalid Email Format**:
```json
{
  "detail": "Invalid email format"
}
```
- HTTP Status: 422 Unprocessable Entity
- Cause: Email doesn't match RFC 5322 pattern
- User Action: Provide valid email address

**Password Too Short**:
```json
{
  "detail": "Password must be at least 8 characters"
}
```
- HTTP Status: 422 Unprocessable Entity
- Cause: len(password) < 8
- User Action: Provide longer password

**Verification Expired**:
```json
{
  "success": false,
  "error": "Verification expired"
}
```
- HTTP Status: 200 (error in body)
- Cause: expires_at < now (>10 minutes)
- User Action: Restart registration flow

**Invalid Verification Code**:
```json
{
  "success": false,
  "error": "Invalid verification code"
}
```
- HTTP Status: 200 (error in body)
- Cause: Code mismatch
- User Action: Re-enter code or request new one

**Account Creation Failed**:
```json
{
  "success": false,
  "error": "Account creation failed"
}
```
- HTTP Status: 200 (error in body)
- Cause: Account service error or unavailable
- User Action: Retry later or contact support

**Invalid Pending Registration**:
```json
{
  "success": false,
  "error": "Invalid pending registration"
}
```
- HTTP Status: 200 (error in body)
- Cause: pending_registration_id not found
- User Action: Restart registration flow

### Device Errors

**Invalid Device Credentials**:
```json
{
  "success": false,
  "authenticated": false,
  "error": "Invalid device credentials"
}
```
- HTTP Status: 200 or 401
- Cause: device_id not found or secret hash mismatch
- User Action: Check device_id and secret, or re-register

**Device Not Found**:
```json
{
  "success": false,
  "error": "Device not found or unauthorized"
}
```
- HTTP Status: 200 or 404
- Cause: device_id doesn't exist or wrong organization
- User Action: Verify device_id and organization

**Unauthorized Operation**:
```json
{
  "success": false,
  "error": "Device not found or unauthorized"
}
```
- HTTP Status: 200 or 403
- Cause: organization_id mismatch
- User Action: Check organization ownership

**Expired Pairing Token**:
```json
{
  "valid": false,
  "error": "Token has expired"
}
```
- HTTP Status: 200
- Cause: expires_at < now (>5 minutes)
- User Action: Generate new pairing token

**Token Already Used**:
```json
{
  "valid": false,
  "error": "Token has already been used"
}
```
- HTTP Status: 200
- Cause: used=true in database
- User Action: Generate new pairing token

**Token Device Mismatch**:
```json
{
  "valid": false,
  "error": "Token does not match device"
}
```
- HTTP Status: 200
- Cause: token device_id != provided device_id
- User Action: Verify device_id and token

**Device Token Type Invalid**:
```json
{
  "valid": false,
  "error": "Invalid token type"
}
```
- HTTP Status: 200
- Cause: type != "device" in token payload
- User Action: Obtain device token, not user token

### API Key Errors

**Invalid Key Format**:
```json
{
  "valid": false,
  "error": "Invalid API key"
}
```
- HTTP Status: 200
- Cause: Key format incorrect or hash lookup failed
- User Action: Check API key string

**Expired Key**:
```json
{
  "valid": false,
  "error": "Invalid or expired API key"
}
```
- HTTP Status: 200
- Cause: expires_at < now
- User Action: Create new API key

**Revoked Key**:
```json
{
  "valid": false,
  "error": "Invalid or expired API key"
}
```
- HTTP Status: 200
- Cause: is_active=false
- User Action: Create new API key (cannot reactivate)

**API Key Not Found**:
```json
{
  "success": false,
  "error": "API key not found"
}
```
- HTTP Status: 200 or 404
- Cause: key_id doesn't exist or wrong organization
- User Action: Verify key_id and organization

**Organization Not Found (for API Key)**:
```json
{
  "success": false,
  "error": "Organization not found"
}
```
- HTTP Status: 200 or 404
- Cause: organization_id doesn't exist
- User Action: Verify organization exists

### Refresh Token Errors

**Invalid Refresh Token**:
```json
{
  "success": false,
  "error": "Invalid or expired refresh token"
}
```
- HTTP Status: 200 or 401
- Cause: Signature invalid, expired, or wrong token_type
- User Action: Re-authenticate to obtain new token pair

**Wrong Token Type for Refresh**:
```json
{
  "success": false,
  "error": "Token refresh failed"
}
```
- HTTP Status: 200
- Cause: token_type != "refresh"
- User Action: Provide refresh token, not access token

**JWT Manager Unavailable (Refresh)**:
```json
{
  "success": false,
  "error": "JWT manager not available"
}
```
- HTTP Status: 200
- Cause: jwt_manager dependency not injected
- User Action: Service configuration issue

### Generic Error Response Format

All errors follow consistent structure:
```json
{
  "success": false,
  "error": "Error message",
  "details": "Optional detailed explanation"
}
```

Or FastAPI HTTPException format:
```json
{
  "detail": "Error message"
}
```

**HTTP Status Codes**:
- 200 OK: Error in response body (for validation/business logic errors)
- 400 Bad Request: Malformed request
- 401 Unauthorized: Authentication failed
- 403 Forbidden: Authorized but insufficient permissions
- 404 Not Found: Resource doesn't exist
- 422 Unprocessable Entity: Validation error
- 500 Internal Server Error: Unexpected server error

**Logging**:
- All errors logged with logger.error() or logger.warning()
- Sensitive data (passwords, secrets, tokens) excluded from logs
- Exception stack traces included in error logs
- Correlation IDs for request tracing (future)

## Security Contracts

### Secret Storage and Handling

**SC-001: Device Secrets**
- Never store plaintext secrets in database
- Always hash with SHA-256 before storage
- Return plaintext only during registration (one-time)
- No mechanism to retrieve original secret after registration
- Secret refresh generates new secret, invalidates old

**SC-002: API Keys**
- Never store plaintext keys in database
- Always hash with SHA-256 before storage
- Return plaintext only during creation (one-time)
- No mechanism to retrieve original key after creation
- Key revocation permanent (no reactivation)

**SC-003: User Passwords**
- Current implementation: stored in pending_registrations (NOT PRODUCTION SAFE)
- Future: Hash with bcrypt or Argon2 before storage
- Never log passwords
- Never return passwords in API responses
- Password reset flow required (future implementation)

**SC-004: JWT Secrets**
- JWT_SECRET loaded from environment variable
- Minimum 32 bytes recommended
- Shared across all auth service replicas
- Rotated periodically (manual process, requires re-deployment)
- Never logged or exposed in API responses

### Token Security

**SC-005: Token Expiration**
- Access tokens: 1 hour (3600 seconds) - short-lived
- Refresh tokens: 7 days (604800 seconds) - long-lived
- Device tokens: 24 hours (86400 seconds) - medium-lived
- Pairing tokens: 5 minutes (300 seconds) - very short-lived
- No extension of tokens (must refresh or re-authenticate)

**SC-006: Token Signature Algorithm**
- isa_user tokens: HS256 (HMAC-SHA256, symmetric)
- Auth0 tokens: RS256 (RSA-SHA256, asymmetric)
- No algorithm flexibility (prevents algorithm confusion attacks)
- Signature verified on every token use

**SC-007: Token Revocation**
- Current: Stateless JWT (no immediate revocation)
- Revoked devices/API keys checked during authentication
- Future: Token blacklist for immediate revocation
- Session invalidation for logout (future implementation)

**SC-008: Refresh Token Rotation**
- Current: No rotation (refresh token reusable)
- Future: Implement refresh token rotation for security
- Single-use refresh tokens prevent token theft scenarios
- Rotation requires session/blacklist storage

### Authentication Security

**SC-009: Rate Limiting**
- Future: Implement rate limiting on authentication endpoints
- Prevent brute force attacks on verification codes
- Limit token generation requests
- Limit device authentication attempts
- Monitor for suspicious patterns

**SC-010: Audit Logging**
- All authentication events logged
- Failed authentication attempts tracked
- Device registration and revocation logged
- API key creation and revocation logged
- Sensitive data excluded from logs

**SC-011: Organization Isolation**
- API keys scoped to organization
- Devices scoped to organization
- Cross-organization access prevented
- Organization ownership verified for all operations
- No global admin bypass (organization-level permissions only)

**SC-012: Credential Rotation**
- Device secrets rotatable via refresh endpoint
- API keys rotatable via revoke + create
- JWT secrets rotated manually (requires coordination)
- Rotation doesn't invalidate active tokens (expiration-based)

### Input Validation

**SC-013: Email Validation**
- Format validation (basic regex or library)
- Normalization (lowercase, trim)
- No SQL injection (parameterized queries)
- Length limits (database constraints)

**SC-014: Token Validation**
- Signature verification before processing
- Expiration check before processing
- Token type validation for operation
- No unverified token decoding for business logic

**SC-015: Device ID Validation**
- Uniqueness enforced (database constraint)
- No special character injection
- Length limits (database constraints)
- Organization ownership verified

**SC-016: API Key Validation**
- Hash comparison (constant-time if possible)
- Expiration check before hash comparison
- Active status check before hash comparison
- Organization ownership verified

---

## Document Metadata

**Document Version**: 1.0
**Last Updated**: 2025-12-13
**Layer**: Layer 5 - Logic Contract
**Service**: auth_service
**Total Business Rules**: 50
**Total State Machines**: 3
**Total Edge Cases**: 15
**Total Data Consistency Rules**: 10
**Total Integration Contracts**: 4
**Total Error Scenarios**: 30+
**Total Security Contracts**: 16

**Maintained By**: Authentication Service Team
**Review Frequency**: Quarterly or on major feature changes
**Related Documents**:
- Layer 1: Domain Context (docs/domain/auth_service.md)
- Layer 2: PRD (docs/prd/auth_service.md)
- Layer 3: Architecture Design (docs/design/auth_service.md)
- Layer 4: API Contract (tests/contracts/auth/api_contract.md - future)
- Layer 6: Data Contract (tests/contracts/auth/data_contract.md - future)
